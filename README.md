# dismathportfolio-ShawnReece
dismathportfolio-ShawnReece created by Classroom for GitHub

Hi, My name is Shawn Reece Tan Wu.

**Week 1:**

*-I just found out that there are many kinds of truth*

They are:

1. **Legal truth** (**Judicial system**) is decided by a *judge or jury* based on the allowable evidence presented at trial.

2. **Authoritative truth** (*Business*) is specified by a *trusted person or organization*, or maybe just your boss.

3. **Scientific truth** is confirmed by *experiment* but only scientific falsehood can be demonstrated by an experiment—when the experiment fails to behave as predicted.

4. **Probable truth** is established by *statistical analysis* of sample data.

5. **Philosophical proof** involves careful exposition and persuasion typically based on a series of small, plausible arguments.

but our target is most likly to be the **_probable truth_**.

-I also found out that word can sometimes be a symbol:

    operator      (symbol)    -usage

1. negation ( ¬ )        -not

2. conjunction      ( ^ )         -and

3. disjunction      ( v )        -or

4. exclusive or     ( + )         -xor

5. conditional      ( 	→	 )     -if, then

6. biconditional   ( 	↔	 )      -Iff

*- I also learn how to use the "Truth Table" which is quite interesting.*

*- Truth Value as bit where p is T and q is False*

**Week 2:**

**-I have learn that in the conditional, thier can be converse and contrapositive of it.**

            p	→	q

* contrapositive - ¬p	→  ¬q

* converse - q	→	p

**Equivalence	Name**

p∧T≡p

p∨F≡p	     ---**Identity laws**


p∨T≡T

p∧F≡F	     ---**Domination laws**


p∨¬p≡T

p∧¬p≡F	     ---**Negation laws**


p∨p≡p

p∧p≡p	     ---**Idempotent laws**


¬(¬p)≡p	     ---**Double negation law**


p∨q≡q∨p

p∧q≡q∧p	     ---**Commutative laws**


(p∨q)∨r≡p∨(q∨r)

(p∧q)∧r≡p∧(q∧r)	     ---**Associative laws**


p∨(q∧r)≡(p∨q)∧(p∨r)

p∧(q∨r)≡(p∧q)∨(p∧r)	     ---**Distributive laws**


¬(p∧q)≡¬p∨¬q

¬(p∨q)≡¬p∧¬q	     ---**De Morgan's laws**


p∨(p∧q)≡p

p∧(p∨q)≡p	     ---**Absorption laws**

*- plus kinds of Quantifiers*

**Existential Quantifiers** - true if "there exist" at least one true and not if all are false

**Universal Quantifiers** - true if all are true and not if one that exist is false


**Week 3:**

*-I have learn the rule of inference.*

they are:

* **argument** - sequence of statement that ends with a conclusion

* **valid** -  Tautology meaning it is always true and never false

* **fallacy** - common form of incorrect reasoning which leads to invalid arguments


For **Tautology**:

**Rules of Inference:**

*Modus ponens

*Modus tollens

*Hyopthetical Syllogism

*Disjunctive Syllogism

*Addition

*Simplification

*Conjunction

*Resolution


**Week 4:**

*-I have learn the kinds or methods of proof or should i say proving.*

*as for now these are the methods i have learn this week.*

*Direct Proof

*Proof by Contraposition (Indirect)

*Vacuous and Trivial Proof

*Proof by Contradiction (Indirect)


**Direct Proof** - always assume p to be true then show tha q is also

Next

**Contraposition** - first is to say that not q is true then prove not p is also true

Next

the **Vacuous proof** - show that p is false when p implies q is true so its like not p implies quantity of p implies q or q implies quantity of p implies q

and Lastly 

some part of **Contradiction** - somewhat confusing but if my understanding is correct that assume not p is true then show that not p really ends a contradiction.

**Week 5**

*- I have learned the other kind of proof.*

and they are:

**Proof by equivalence** - by proving statement *biconditionally* that is true in both ways

**Induction** - *first basis true with example  then induction ( another assume then Show that it's really true)* >very tricky

*-he also introduced the _Introduction of summation_.* >just awhile didn't take more than 2 min.

*-Finally the last topic he discussed that is very tricky and kinda learn* >but not sure if its kinda easy to understand though i get what he meant.

**Reursive** -first basis specify the value of function at 0 > didn't quite get what it meant but ok? then recursive step

*recursive step* - give a rule for finding thr its value at an integer from its value at smaller > not sure at this but i kinda did get and kinda not.


**Week 6**

*-I have learn this week was the:*

first - **Recursive Algorithm** > quite not there yet since im still beginning programming

second - **Program Correctness** > this is just like provong that the problem is alwys true by this kinds of style:

**insights** - first show that the correct answer is obtained if it terminates (**Partial Correctness**) then show it or prove it that it *always terminates*

2 proposition - **Intial and Final Assertion**

which goes to the **Hoare Triple** --**p{s}q**

**4 kinds of style**

*rule of inference - p{s1}q ^ q{s2}r = p{s1,s2}r

*conditional Statement - (p^condition){s}q ^ (p^condition)-> q = p{if condition then s}q

*If_Else Statement - (p^condition){s1}q ^ (p^condition){s2}q = p{if condition then s1 else s2}q

-I learn next was the formula of **Geometric Series** - a1/(1-r)

and two kind of series: 

1. Convergent - continuous but countable >i think
2. Divergent - infinite continuity

Next is the ** Power Series** - similar as geometric series - a0/(1-x)

And lastly **Set Theory**

**Set Theory** - is the *unordered colllection of distinct collection*

**Power Set** - a set of sets

**Week 7**

*-what i learn this week was the **Cardinality** of set of number of element it contains.

> pretty much some ideas about it, i think

*-And ofcourse we reviewed for the test at friday.

>and nothing pretty much after that.

**Week 8**

*-what i have learned this week was the __Algorithm__*

**Algorithm** - is a finite set of instruction for performing a computationalist or for solving a problem

**Pseudocode** - high-level description of an algorithm that use structural conventions of a programming language

**Parts of the Pseudocode**

1. Input
2. output
3. Definiteness
4. Correctness
5. Finiteness
6. Generality

Another kind of Algorithm was the **Searching Algorithm** and **Binary Search Algorithm**

And another is **Iteration** which kinda like the truth table.

**Week 9**

*- I hae learned are:*

1. **Search** - just search it accordingly for the location of the desired ouput
2. **Binary** - just search it in order by dividing the search by half  and half of remain like a loop till it search the desired output location.
3. **Bubble sort** - what it does just make the numbers in order by comparing first and the one beside the first than the one being compared is now comparing the beside it then goes on like a loop then back to start after ireaches the end
4. **insert sort** - just the same thing as ordering by order but in a different way - not sure how to explain and not sure if im sure with the understanding of this
5. **Greedy Algorith** - is something like changes on money

**Week 10**

*-i have learned this week was the*

1. **growth of function**-using big O, omega, and theta although i dont get it somehow I think there is something missing in this lesson


**Week 10**

*I have learned the graph*

**Graph** – discrete structures consisting of vertices and edges that connect these vertices.

*A graph G = (V, E)* consists of V, a nonempty set of *vertices (or nodes )* and E, a set of edges. Each *edge* has either one or two vertices associated with it, called its *endpoints*.

The *degree* of a vertex in an undirected graph is the number of edges incident with it, except that a loop at a vertex contributes twice to the degree of that vertex.

**Handshaking Theorem** - 2e equals summation of deg v

A *subgraph* of a graph G - A subgraph H of G is a proper subgraph of G if H G.

The *union* of two simple graphs is the simple graph with vertex and edge.

*path* is a sequence of edges that begins at a vertex of a graph and travels from vertex to vertex along edges of the graph.

**Euler circuit** in a graph G is a simple circuit containing every edge of G.

A simple path in a graph G that passes through every vertex exactly once is called a *Hamilton path*, and a simple circuit in a graph G that passes through every vertex exactly once is called a *Hamilton circuit*

**Matrices of Graphs - incidence matrix**

**Isomorphism of Graphs** - same function just reshape and can be returned to its original

**Planar graph** – are graphs that can be drawn in the plane without edges having to cross.

**Euler's Formula** - r = e - v + 2 -the number of regions in a planar representation of G

**Kuratowski's Theorem** - A graph is nonplanar if and only if it contains a subgraph homeomorphic

**Week 11**

*-what i have learned this week are:*

-**Graphing Color** -this is the map that all same colors are not adjacent to each other and solving to how many color minimun that can be used

**FOUR COLOR THEOREM** - it means to say that the maximun you can get is four color that has no same adjacent color or in short The chromatic number of a planar graph is no greater than four for planar only

**tree** is a connected undirected graph with no simple circuits and is a data structure that emulates a hierarchical tree structure with a set of linked nodes

A **rooted tree** is called an **m-ary tree** if every internal vertex has no more than m children. The tree is called a full m-ary tree if every internal vertex has exactly m children.

**Ordered rooted tree** - a rooted tree where the children of each internal vertex are ordered.

**Properties of Trees**

-A tree with n vertices has n - 1 edges.
-A full m-ary tree with i internal vertices contains n = mi + 1 vertices.
-A full m-ary tree with

(i) n vertices has i = (n - 1)/ m internal vertices and l = [(m - 1)n + 1 ]/ m leaves,

(ii) i internal vertices has n = mi + 1 vertices and I = (m - 1)i + 1 leaves,

(iii ) l leaves has n = (ml - 1 )/(m - 1) vertices and i = (l - 1 )/(m - 1) internal vertices.

**Tree Traversals**

http://geeksforgeeks.org/wp-content/uploads/2009/06/tree12.gif

-Inorder
-Preorder
-Postorder

Inorder Traversal:
-Algorithm Inorder(tree)
   1. Traverse the left subtree, i.e., call Inorder(left-subtree)
   2. Visit the root.
   3. Traverse the right subtree, i.e., call Inorder(right-subtree)
Example: Inorder traversal for the above given figure is 4 2 5 1 3.

Preorder Traversal:
-Algorithm Preorder(tree)
   1. Visit the root.
   2. Traverse the left subtree, i.e., call Preorder(left-subtree)
   3. Traverse the right subtree, i.e., call Preorder(right-subtree)
Example: Preorder traversal for the above given figure is 1 2 4 5 3.

Postorder Traversal:
-Algorithm Postorder(tree)
   1. Traverse the left subtree, i.e., call Postorder(left-subtree)
   2. Traverse the right subtree, i.e., call Postorder(right-subtree)
   3. Visit the root.
Example: Postorder traversal for the above given figure is 4 5 2 3 1.

A **spanning tree** is a subset of Graph G, which has all the vertices covered with minimum possible number of edges. Hence, a spanning tree does not have cycles and it can not be disconnected.

An **equivalence relation** on a set X is a subset of X×X, i.e., a collection R of ordered pairs of elements of X, satisfying certain properties. Write "xRy" to mean (x,y) is an element of R, and we say "x is related to y," then the properties are

1. Reflexive: aRa for all a in X,

2. Symmetric: aRb implies bRa for all a,b in X

3. Transitive: aRb and bRc imply aRc for all a,b,c in X, where these three properties are completely independent. 

4. Other notations are often used to indicate a relation, e.g., a=b or a∼b.


A **relation "<=" is a partial order** on a set S if it has:

1. Reflexivity: a<=a for all a in S.

2. Antisymmetry: a<=b and b<=a implies  a=b.

3. Transitivity: a<=b and b<=c implies  a<=c.

For a partial order, the size of the longest chain (antichain) is called the partial order length (partial order width). A partially ordered set is also called a poset.
   
   
   
